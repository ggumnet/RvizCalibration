#!/usr/bin/env python
PACKAGE = "pg_editor"

from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator()

matcher_tools = gen.add_group("Matcher tools")
seq_matcher = matcher_tools.add_group("Sequential matcher", type="tab")
seq_matcher.add("seq_start_index", int_t, 0, "[IN] Start index", 0, 0, 1000000)
seq_matcher.add("seq_end_index", int_t, 0, "[IN] End index", 0, 0, 1000000)
seq_matcher.add("seq_incr_index", int_t, 0, "[IN] Increment of index", 1, 1, 100)
seq_matcher.add("seq_match", bool_t, 1, "[IN] Match pointclouds sequentially according to start/end/increment of indices", False)
seq_matcher.add("use_prev_result_as_pose_guess", bool_t, 0, "[IN] Use previous matching result as pose guess of current matching", False)

intvl_matcher = matcher_tools.add_group("Interval matcher", type="tab")
ref_time_intvl = intvl_matcher.add_group("Reference interval")
ref_time_intvl.add("intvl_start_index_ref", int_t, 0, "[IN] Start reference index", 0, 0, 1000000)
ref_time_intvl.add("intvl_end_index_ref", int_t, 0, "[IN] End reference index", 0, 0, 1000000)
ref_time_intvl.add("intvl_incr_index_ref", int_t, 0, "[IN] Increment of reference index", 1, 1, 100)
in_time_intvl = intvl_matcher.add_group("Input interval")
in_time_intvl.add("intvl_start_index_in", int_t, 0, "[IN] Start input index", 0, 0, 1000000)
in_time_intvl.add("intvl_end_index_in", int_t, 0, "[IN] End input index", 0, 0, 1000000)
intvl_matcher.add("intvl_max_num_neighbors", int_t, 0, "[IN] Maximum number of neighbors of each pointcloud whose index is contained within reference interval", 1, 0, 1000)
intvl_matcher.add("intvl_max_distance", double_t, 0, "[IN] Maximum distance between neighbors and each pointcloud whose index is contained within reference interval", 10, 0, 1000)
intvl_matcher.add("intvl_match", bool_t, 2, "[IN] Match pointclouds within specified intervals", False)

pose_matcher = matcher_tools.add_group("Pose matcher", type="tab")
pose_matcher.add("pose_start_index_ref", int_t, 0, "[IN] Start index of references for pose matches", 0, 0, 1000000)
pose_matcher.add("pose_end_index_ref", int_t, 0, "[IN] End index of references for pose matches", 0, 0, 1000000)
pose_matcher.add("pose_start_index", int_t, 0, "[IN] Start index for pose matches", 0, 0, 1000000)
pose_matcher.add("pose_end_index", int_t, 0, "[IN] End index for pose matches", 0, 0, 1000000)
pose_matcher.add("pose_max_distance", double_t, 0, "[IN] Maximum distance between pointclouds that can be neighbors each other", 15, 0, 100)
pose_matcher.add("pose_interval_threshold_for_group", int_t, 0, "[IN] Interval threshold of indices for grouping", 5, 1, 100)
pose_matcher.add("pose_max_group_size", int_t, 0, "[IN] Maximum size of each group (0: all)", 1, 0, 10)
pose_matcher.add("pose_max_z_diff", double_t, 0, "[IN] Maximum difference of z-value of neighboring poses", 1, 0, 10)
pose_matcher.add("H_threshold", double_t, 0, "[IN] Threshold of hessian value to skip matching", 0.0001, 0, 1000)
pose_matcher.add("pose_match", bool_t, 8, "[IN] Match all pointcloud pairs that are located within specified distance threshold", False)


req = matcher_tools.add_group("Requirement to add into graph")
req.add("use_requirements", bool_t, 0, "[IN] Use requirements", True)
req.add("do_break", bool_t, 0, "[IN] Do break when conditions are not satisfied", False)
trans_bound = req.add_group("Transformation bounds")
trans_bound.add("roll_min", double_t, 0, "[IN] Minimum value of valid range of roll (deg)", -3, -90, 90)
trans_bound.add("roll_max", double_t, 0, "[IN] Maximum value of valid range of roll (deg)", 3, -90, 90)
trans_bound.add("pitch_min", double_t, 0, "[IN] Minimum value of valid range of pitch (deg)", -3, -90, 90)
trans_bound.add("pitch_max", double_t, 0, "[IN] Maximum value of valid range of pitch (deg)", 3, -90, 90)
trans_bound.add("yaw_min", double_t, 0, "[IN] Minimum value of valid range of yaw (deg)", -10, -180, 180)
trans_bound.add("yaw_max", double_t, 0, "[IN] Maximum value of valid range of yaw (deg)", 10, -180, 180)
trans_bound.add("x_min", double_t, 0, "[IN] Minimum value of valid range of x (m)", -5, -100, 100)
trans_bound.add("x_max", double_t, 0, "[IN] Maximum value of valid range of x (m)", 5, -100, 100)
trans_bound.add("y_min", double_t, 0, "[IN] Minimum value of valid range of y (m)", -5, -100, 100)
trans_bound.add("y_max", double_t, 0, "[IN] Maximum value of valid range of y (m)", 5, -100, 100)
trans_bound.add("z_min", double_t, 0, "[IN] Minimum value of valid range of z (m)", -0.5, -10, 10)
trans_bound.add("z_max", double_t, 0, "[IN] Maximum value of valid range of z (m)", 0.5, -10, 10)
req.add("check_convergence", bool_t, 0, "[IN] Check that optimization of matching is converged", True)
req.add("dist_threshold_to_initial_guess", double_t, 0, "[IN] Distance threshold to initial guess (0: unused)", 0, 0, 100)

vis_tools = gen.add_group("Visualization tools")
play_vis = vis_tools.add_group("Play", type="tab")
play_vis.add("play_map_pointcloud", bool_t, 4, "[IN] Play map pointcloud", False)
play_vis.add("frame_rate", int_t, 0, "[IN] Frame rate of playing map pointcloud", 10, 1, 100)
play_vis.add("start_frame", int_t, 0, "[IN] Start frame index of playing map pointcloud", 0, 0, 1000000)
region_vis = vis_tools.add_group("Region", type="tab")
region_vis.add("visualize_region_pointcloud", bool_t, 16, "[IN] Visualize region-pointcloud", False)
region_vis.add("x_center", double_t, 0, "[IN] X-value of center position of region", 0, -5000, 5000)
region_vis.add("y_center", double_t, 0, "[IN] Y-value of center position of region", 0, -5000, 5000)
region_vis.add("width", double_t, 0, "[IN] Width of region", 50, 0, 10000)
region_vis.add("height", double_t, 0, "[IN] Height of region", 50, 0, 10000)
region_vis.add("region_intvl", int_t, 0, "[IN] Index interval of region-pointcloud", 5, 1, 100)

remove_tools = gen.add_group("Remove tools")
var_remove = remove_tools.add_group("Variable removal")
var_remove.add("remove_vars", bool_t, 32, "[IN] Remove specified nodes", False)
var_remove.add("remove_start_index", int_t, 0, "[IN] Start index for removal", 0, 0, 1000000)
var_remove.add("remove_end_index", int_t, 0, "[IN] End index for removal", 0, 0, 1000000)
var_remove.add("remove_x_min", double_t, 0, "[IN] Minimum value of valid range of x for removal (m)", 0, -5000, 5000)
var_remove.add("remove_x_max", double_t, 0, "[IN] Maximum value of valid range of x for removal (m)", 0, -5000, 5000)
var_remove.add("remove_y_min", double_t, 0, "[IN] Minimum value of valid range of y for removal (m)", 0, -5000, 5000)
var_remove.add("remove_y_max", double_t, 0, "[IN] Maximum value of valid range of y for removal (m)", 0, -5000, 5000)
var_remove.add("remove_z_min", double_t, 0, "[IN] Minimum value of valid range of z for removal (m)", 0, -500, 500)
var_remove.add("remove_z_max", double_t, 0, "[IN] Maximum value of valid range of z for removal (m)", 0, -500, 500)
var_remove_id = remove_tools.add_group("Variable removal frome sensor id")
var_remove_id.add("remove_vars_from_id", bool_t, 32, "[IN] Remove nodes from sensor id", False)
var_remove_id.add("remove_vehicle", str_t, 0, "[IN] Vehicle name used for variables removal", "ionic")
var_remove_id.add("remove_bag_time", str_t, 0, "[IN] Bag time used for variables removal", "2020-01-01-00-00-00")
var_remove_id.add("remove_sensor", str_t, 0, "[IN] Sensor name used for variables removal", "hesai_pc_und")
var_remove_sel = remove_tools.add_group("Selected Variable removal")
var_remove_sel.add("remove_selected_vars", bool_t, 32, "[IN] Remove selected nodes", False)

exit(gen.generate(PACKAGE, "graph_editor_tool", "GraphEditorTool"))

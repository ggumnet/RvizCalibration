#!/usr/bin/env python
PACKAGE = "pg_editor"

from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator()

vis = gen.add_group("Visualization")
#vis.add("update_absolute_transform", bool_t, 0, "Visualize relative transform visualization data", False)
vis.add("update_relative_transform", bool_t, 0, "Visualize relative transform visualization data", True)
vis.add("update_mapper", bool_t, 0, "Update mapper visualization data", True)
vis.add("marker_scale", double_t, 0, "[IN] Scale of interactive markers", 3, 1, 100)
vis.add("refresh", bool_t, 32, "Refresh visualization data", False)
vis_pc = vis.add_group("Map pointcloud")
vis_pc.add("publish_pointcloud", bool_t, 16, "[IN] Publish map pointcloud", False)
vis_pc.add("index_interval", int_t, 0, "[IN] Index interval of pointclouds that form map pointcloud message", 20, 1, 1000)
vis_pc.add("start_index", int_t, 0, "[IN] End index interval of pointclouds that form map pointcloud message", 0, 0, 1000000)
vis_pc.add("end_index", int_t, 0, "[IN] Start index of pointclouds that form map pointcloud message", 0, 0, 1000000)

matcher_index = vis.add_group("Indices")
matcher_index.add("index_ref", int_t, 0, "[IN] Index of reference pointcloud", 0, 0, 1000000)
matcher_index.add("index_in", int_t, 0, "[IN] Index of input pointcloud", 1, 0, 1000000)

pc_map = gen.add_group("Pointcloud Generation", type="collapse", state=False)
pc_map.add("pc_map_filename", str_t, 0, "[IN] Filename of pointcloud map", "/tmp/pointcloud_map")
pc_map.add("tile_size", double_t, 0, "[IN] Size of tiles of pointcloud map", 5000, 0, 5000)
pc_map.add("save_pc_map", bool_t, 32768, "[IN] Save created map pointcloud as bin file", False)

mapper = gen.add_group("Mapper", type="collapse", state=False)
#mapper.add("mapper_output_message", str_t, 0, "[OUT] Output message from mapper", "")
mapper.add("optimize", bool_t, 8, "[IN] Optimize current graph", False)
mapper.add("variable_index", int_t, 0, "[IN] Index of variable to select", 0, 0, 1000000)
mapper.add("factor_index", int_t, 0, "[IN] Index of factor of selected variable to select", 0, 0, 100)
mapper.add("print_factor_infos", bool_t, 128, "[IN] Print array of factor infos of selected variable", False)
mapper.add("show_selected_factor", bool_t, 1024, "[IN] Show selected factor", False)
mapper.add("remove_factor", bool_t, 512, "[IN] Remove selected factor", False)
mapper.add("remove_variable", bool_t, 256, "[IN] Remove selected variable", False)
mapper.add("recompute_inconsistent_relative_factors", bool_t, 2048, "[IN] Recompute all relative factors whose costs are larger than cost_threshold in graph", False)
mapper.add("remove_all_absolute_factors", bool_t, 8192, "[IN] Remove all absolute pose factors in graph", False)
mapper.add("enumerate_inconsistent_factors", bool_t, 4096, "[IN] Enumerate factors sorted according to their costs", False)
mapper.add("show_largest_cost_factor", bool_t, 8, "[IN] Show factor which has largest cost ", False)
mapper.add("show_next", bool_t, 8, "[IN] Show factor which has largest cost ", False)
mapper.add("show_prev", bool_t, 8, "[IN] Show factor which has largest cost ", False)
mapper.add("remove_inconsistent_factors", bool_t, 16384, "[IN] Remove inconsistent factors according to their costs", False)
mapper.add("use_initial_poses_from_pointcloud_server", bool_t, 0, "[IN] Use poses of pointcloud server as initial poses of optimization", False)
mapper.add("cost_threshold", double_t, 0, "[IN] Cost threshold for classifying inconsistent factors", 1., 0, 10)
mapper.add("reduce_density_radius", double_t, 32768, "[IN] radius for checking number of point", 2., 1, 10)
mapper.add("reduce_density_points", int_t, 32768, "[IN] Cost threshold for classifying inconsistent factors", 3, 1, 10000)
mapper.add("reduce_density", bool_t, 32768, "[IN] Optimize current graph", False)

absolute_transform = gen.add_group("Absolute transform", type="collapse", state=False)
abs_enum = gen.enum([gen.const("AbsolutePose", int_t, 0, "AbsolutePoseFactor"),
                     gen.const("AbsolutePointPose", int_t, 1, "AbsolutePointPoseFactor")],
                    "An enum of types of absolute poses")
#absolute_transform.add("add_absolute_transform_to_graph", bool_t, 256, "[IN] Add relative transform between reference and input indices of pointclouds as a factor", False)
default_cov_abs = absolute_transform.add_group("Default covariance of absolute transform")
default_cov_abs.add("use_default_covariance_abs", bool_t, 0, "[IN] Use default covariance of absolute transform", True)
default_cov_abs.add("use_quality_number", bool_t, 0, "[IN] Use GT quality number in covariance of absolute transform", True)
default_cov_abs.add("default_covariance_abs_values", str_t, 0, "[IN] Values of diagonal elements of default covariance of absolute transform", "1e-0 1e-0 1e-0 1e-0 1e-0 1e-0")
file_abs = absolute_transform.add_group("Absolute transforms from file")
file_abs.add("absolute_transform_sensor_frame_id", str_t, 0, "[IN] Frame id of sensor used for acquiring measurements to compute absolute transforms", "nov_imu")
file_abs.add("use_poses_in_graph_only", bool_t, 0, "[IN] Use transforms of poses in graph only", False)
file_abs.add("absolute_transform_type", int_t, 0, "[IN] Type of absolute transforms in the file", 0, 0, 1, edit_method=abs_enum)
from_pose = file_abs.add_group("From Pose", type="tab")
from_pose.add("add_absolute_transform_from_file", bool_t, 64, "[IN] Add absolute transforms from file", False)
from_pose.add("absolute_transform_filename", str_t, 0, "[IN] Filename contains absolute transforms", "")
from_zone = file_abs.add_group("From Zone", type="tab")
from_zone.add("add_absolute_transform_from_zone_file", bool_t, 64, "[IN] Add absolute transforms from zone file", False)
from_zone.add("absolute_transform_zone_filename", str_t, 0, "[IN] Filename zone information", "")
from_zone.add("absolute_transform_map_frame_id", str_t, 0, "[IN] Frame id of map used for acquiring measurements to compute absolute transforms", "")
from_zone.add("pc_path", str_t, 0, "[IN] Path of pc in output directory", "")
sensor_id = file_abs.add_group("Sensor Info")
sensor_id.add("vehicle", str_t, 0, "[IN] Vehicle name used for acquiring absolute transform data", "ionic")
sensor_id.add("bag_time", str_t, 0, "[IN] Bag time used for acquiring absolute transform data", "2020-01-01-00-00-00")
sensor_id.add("sensor", str_t, 0, "[IN] Sensor name used for acquiring absolute transform data", "hesai_pc_und")

relative_transform = gen.add_group("Relative transform", type="collapse", state=False)
relative_transform.add("match", bool_t, 1, "[IN] Match two pointclouds", False)
relative_transform.add("roiMatch", bool_t, 1, "[IN] Match two pointclouds with ROI", False)
relative_transform.add("add_relative_transform_to_graph", bool_t, 2, "[IN] Add relative transform between reference and input indices of pointclouds as a factor", False)
relative_transform.add("set_identity", bool_t, 4, "[IN] Set relative transform to identity", False)
relative_transform.add("use_poses_from_pointcloud_server", bool_t, 0, "[IN] Use transforms obtained from pointcloud server to compute relative transformation", False)
default_cov_rel = relative_transform.add_group("Default Covariance of relative transform")
default_cov_rel.add("use_default_covariance_rel", bool_t, 0, "[IN] Use default covariance of relative transform", True)
default_cov_rel.add("default_covariance_rel_values", str_t, 0, "[IN] Values of diagonal elements of default covariance of relative transform", "1e-2 1e-2 1e-2 1e-3 1e-3 1e-3")

exit(gen.generate(PACKAGE, "graph_editor", "GraphEditor"))
